from dotenv import load_dotenv
from agents import Agent, Runner, trace
from openai.types.responses import ResponseTextDeltaEvent
import os
import asyncio

instructions1 = "You are a sales agent working for ComplAI, \
a company that provides a SaaS tool for ensuring SOC2 compliance and preparing for audits, powered by AI. \
You write professional, serious cold emails."

sales_agent1 = Agent(
        name="Professional Sales Agent",
        instructions=instructions1,
        model="gpt-4o-mini"
)

"""
1. Why do we need not await Runner.run_streamed?
- Because Runner.run_streamed() does NOT return a coroutine.
- It returns an object that exposes an async stream (an async iterator / async generator).
- We await coroutines.
- We iterate over async iterables using async for because streams dont finish immediately they produce values over time
"""

"""
2. What can be awaited? 
- a couroutine
- a Task
- a Future
- something implementing __await__()

async def foo():
    return 42

result = await foo() # Will return 42
"""

"""
3. What does Runner.run_streamed() return ? 

class StreamedRunResult:
    def stream_events(self):
        async def generator():
            ...
            yield event
        return generator()
- A controller object that contains a stream of events.
- Accessed via events.stream_events().
"""

"""
4. What is aync for event in .. ? 
- This is asynchronous iteration 
- It loops over the values that arrive over time, where each iteration may need to await internally

for x in [1,2,3]:
    print(x)
uses : __iter__() -> __next()__()

async for x in async_iterable:
    print(x)

uses : __aiter__() -> __anext()__()

import asyncio

async def numbers():
    for i in range(5):
        await asyncio.sleep(1)
        yield i

async for n in numbers():
    print(n)
- Each yield produces a value that can be consumed asynchronously.
- async for pauses execution until the next value is available. So here is where await happens
- We cant use regular for loops with async iterables as next values may not be immediately available
"""

"""

5. Why ResponseTextDeltaEvent ? 
- ResponseTextDeltaEvent is used to represent the incremental updates to the response text as they are generated by the model.
- It allows the system to stream the response in real-time, providing a more interactive and dynamic user experience.
- By using ResponseTextDeltaEvent, we can handle each chunk of the response as it arrives, rather than waiting for the entire response to be generated.
"""

result = Runner.run_streamed(sales_agent1, input="Write a cold sales email")
async for event in result.stream_events():
    if event.type == "raw_response_event" and isinstance(event.data, ResponseTextDeltaEvent):
        # end="" :  print by default add a \n(newline) after execution this prevents it
        # flush=True :  this forces the output to be written immediately, instead of being held in a buffer
        print(event.data.delta, end="", flush=True)